<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<article lang="">
  <para>Предисловие . . 17</para>
  <para>Глава 1. Введение в компьютеры, Internet и World Wide Web 53</para>
  <para>1.1. Введение 54</para>
  <para>1.2. Что такое компьютер? 56</para>
  <para>1.3. Организация компьютера 57</para>
  <para>1.4. Первые операционные системы 58</para>
  <para>1.5. Модели обработки данных: персональная, распределенная</para>
  <para>и клиент/сервер 59</para>
  <para>1.6. Internet и World Wide Web 59</para>
  <para>1.7. Машинные языки, языки ассемблера и языки высокого уровня. . 60</para>
  <para>1.8. История С и C++ 61</para>
  <para>1.9. Стандартная библиотека C++ 62</para>
  <para>1.10. История языка Java 64</para>
  <para>1.11. FORTRAN, COBOL, Pascal и Ada 64</para>
  <para>1.12. BASIC, Visual Basic, Visual C++, C# и .NET 65</para>
  <para>1.13. Ключевая тенденция в программировании: объектная</para>
  <para>технология 66</para>
  <para>1.14. Типичная среда разработки C++ 67</para>
  <para>1.15. Замечания о C++ и этой книге 70</para>
  <para>1.16. Тестовый запуск приложения на C++ 72</para>
  <para>1.17. Конструирование программного обеспечения. Введение</para>
  <para>в объектную технологию и UML (обязательный раздел) 78</para>
  <para>1.18. Заключение 85</para>
  <para>1.19. Ресурсы Web 85</para>
  <para>Глава 2. Введение в программирование на C++ 95</para>
  <para>2.1. Введение 96</para>
  <para>2.2. Первая программа на C++: печать строки текста 96</para>
  <para>2.3. Модификация нашей первой программы 101</para>
  <para>2.4. Другая программа на C++: сложение целых чисел 102</para>
  <para>2.5. Организация памяти 107</para>
  <para>2.6. Арифметика 109</para>
  <para>2.7. Принятие решений: операции равенства и отношений 1136</para>
  <para>Как программировать на C++</para>
  <para>2.8. Конструирование программного обеспечения.</para>
  <para>Исследование требований к ATM (необязательный раздел). . . .118</para>
  <para>2.9. Заключение 129</para>
  <para>Глава 3. Введение в классы и объекты 139</para>
  <para>3.1. Введение 140</para>
  <para>3.2. Классы, объекты, элемент-функции и элементы данных . . . . 141</para>
  <para>3.3. Обзор примеров главы 142</para>
  <para>3.4. Определение класса с элемент-функцией 143</para>
  <para>3.5. Определение элемент-функции с параметром 147</para>
  <para>3.6. Элементы данных, set-функции и gef-функции 151</para>
  <para>3.7. Инициализация объектов при помощи конструкторов 159</para>
  <para>3.8. Размещение класса в отдельном файле 163</para>
  <para>3.9. Отделение интерфейса от реализации 168</para>
  <para>3.10. Подтверждение данных посредством set-функций 174</para>
  <para>3.11. Конструирование программного обеспечения. Идентификация</para>
  <para>классов в спецификации требований к ATM (необязательный</para>
  <para>раздел) 180</para>
  <para>3.12. Заключение 188</para>
  <para>Глава 4. Управляющие операторы: часть I 197</para>
  <para>4.1. Введение 198</para>
  <para>4.2. Алгоритмы 199</para>
  <para>4.3. Псевдокод 199</para>
  <para>4.4. Управляющие структуры 201</para>
  <para>4.5. Оператор выбора if 205</para>
  <para>4.6. Оператор выбора if...else 207</para>
  <para>4.7. Оператор повторения while 212</para>
  <para>4.8. Формулирование алгоритмов: повторение, управляемое</para>
  <para>счетчиком 214</para>
  <para>4.9. Формулирование алгоритмов: повторение, управляемое</para>
  <para>контрольным значением 221</para>
  <para>4.10. Формулирование алгоритмов: вложенные управляющие</para>
  <para>операторы 233</para>
  <para>4.11. Операции присваивания 238</para>
  <para>4.12. Операции инкремента и декремента 239</para>
  <para>4.13. Конструирование программного обеспечения. Идентификация</para>
  <para>классовых атрибутов в системе ATM (необязательный раздел) . 242</para>
  <para>4.14. Заключение 247</para>
  <para>Глава 5. Управляющие операторы: часть II 265</para>
  <para>5.1. Введение 266</para>
  <para>5.2. Основы повторения, управляемого счетчиком 267</para>
  <para>5.3. Оператор повторения for 269</para>
  <para>5.4. Примеры операторов for 274</para>
  <para>5.5. Оператор повторения do...while 279</para>
  <para>5.6. Оператор множественного выбора switch 281</para>
  <para>5.7. Операторы break и continue 292Содержание 7</para>
  <para>5.8. Логические операции 294</para>
  <para>5.9. Случайная подмена операции равенства (==) присваиванием (=). 299</para>
  <para>5.10. Структурное программирование: резюме 301</para>
  <para>5.11. Конструирование программного обеспечения. Идентификация</para>
  <para>состояний объектов и деятельности в системе ATM</para>
  <para>(необязательный раздел) 307</para>
  <para>5.12. Заключение 313</para>
  <para>Глава 6. Функции и введение в рекурсию 325</para>
  <para>6.1. Введение 326</para>
  <para>6.2. Компоненты программ на C++ 327</para>
  <para>6.3. Функции математической библиотеки 329</para>
  <para>6.4. Определения функций с несколькими параметрами 331</para>
  <para>6.5. Прототипы функций и принудительное приведение аргументов . 336</para>
  <para>6.6. Заголовочные файлы стандартной библиотеки C++ 339</para>
  <para>6.7. Пример: генерация случайных чисел 341</para>
  <para>6.8. Пример: азартная игра с использованием перечисления (enum) . 347</para>
  <para>6.9. Классы памяти 351</para>
  <para>6.10. Правила для области действия 355</para>
  <para>6.11. Стек вызовов и активационные записи 358</para>
  <para>6.12. Функции с пустым списком параметров 363</para>
  <para>6.13. Встроенные функции 365</para>
  <para>6.14. Ссылки и ссылочные параметры 366</para>
  <para>6.15. Аргументы по умолчанию 372</para>
  <para>6.16. Унарная операция разрешения области действия 374</para>
  <para>6.17. Перегрузка функций 375</para>
  <para>6.18. Шаблоны функций 379</para>
  <para>6.19. Рекурсия 381</para>
  <para>6.20. Пример рекурсии: числа Фибоначчи 385</para>
  <para>6.21. Рекурсия в сравнении с итерацией 388</para>
  <para>6.22. Конструирование программного обеспечения. Идентификация</para>
  <para>операций классов в системе ATM (необязательный раздел) . . . 392</para>
  <para>6.23. Заключение 400</para>
  <para>Глава 7. Массивы и векторы 423</para>
  <para>7.1. Введение 424</para>
  <para>7.2. Массивы 425</para>
  <para>7.3. Объявление массивов 427</para>
  <para>7.4. Примеры с массивами 428</para>
  <para>7.5. Передача массивов функциям 446</para>
  <para>7.6. Пример: класс GradeBook с массивом для хранения оценок . . . 450</para>
  <para>7.7. Линейный поиск в массивах 457</para>
  <para>7.8. Сортировка массивов вставкой 459</para>
  <para>7.9. Многомерные массивы 461</para>
  <para>7.10. Пример: класс GradeBook с двумерным массивом 465</para>
  <para>7.11. Введение в шаблон класса vector стандартной библиотеки C++ . 4728 Как программировать на C++</para>
  <para>7.12. Конструирование программного обеспечения. Кооперация</para>
  <para>объектов в системе ATM (необязательный раздел) 477</para>
  <para>7.13. Заключение 486</para>
  <para>Глава 8. Указатели и строки-указатели 505</para>
  <para>8.1. Введение 506</para>
  <para>8.2. Объявление и инициализация переменных-указателей 507</para>
  <para>8.3. Операции указателей 508</para>
  <para>8.4. Передача аргументов по ссылке с помощью указателей 512</para>
  <para>8.5. Квалификатор const в применении к указателям 516</para>
  <para>8.6. Сортировка выборкой с передачей по ссылке 524</para>
  <para>8.7. Операции sizeof 527</para>
  <para>8.8. Выражения с указателями и арифметика указателей 530</para>
  <para>8.9. Взаимосвязь указателей и массивов 534</para>
  <para>8.10. Массивы указателей 538</para>
  <para>8.11. Пример: моделирование тасования и сдачи карт 540</para>
  <para>8.12. Указатели на функцию 546</para>
  <para>8.13. Введение в обработку строк-указателей 551</para>
  <para>8.13.1. Элементарные сведения о символах и строках 551</para>
  <para>8.13.2. Функции обработки строк из библиотеки &lt;cstring&gt; 554</para>
  <para>8.14. Заключение 562</para>
  <para>Глава 9. Классы: часть I 591</para>
  <para>9.1. Введение 592</para>
  <para>9.2. Пример: класс Time 593</para>
  <para>9.3. Область действия класса и доступ к элементам класса 601</para>
  <para>9.4. Отделение интерфейса от реализации 603</para>
  <para>9.5. Функции доступа и сервисные функции 604</para>
  <para>9.6. Пример: класс Time. Конструкторы с аргументами</para>
  <para>по умолчанию 607</para>
  <para>9.7. Деструкторы 613</para>
  <para>9.8. Когда вызываются конструкторы и деструкторы 613</para>
  <para>9.9. Пример: класс Time. Скрытая ошибка — возвращение ссылки</para>
  <para>на закрытый элемент данных 617</para>
  <para>9.10. Поэлементное присваивание по умолчанию 620</para>
  <para>9.11. Утилизируемость программного обеспечения 622</para>
  <para>9.12. Конструирование программного обеспечения. Начало</para>
  <para>программирования классов системы ATM</para>
  <para>(необязательный раздел) 623</para>
  <para>9.13. Заключение 631</para>
  <para>Глава 10. Классы: часть II 639</para>
  <para>10.1. Введение 640</para>
  <para>10.2. Константные объекты и константные элемент-функции .... 641</para>
  <para>10.3. Композиция: объекты в качестве элементов класса 651</para>
  <para>10.4. Дружественные функции и дружественные классы 658</para>
  <para>10.5.-Указатель this 662Содержание 9</para>
  <para>10.6. Динамическое управление памятью с помощью операций</para>
  <para>new и delete 668</para>
  <para>10.7. Статические элементы класса 670</para>
  <para>10.8. Абстракция данных и сокрытие информации 677</para>
  <para>10.8.1. Пример: абстрактный тип данных — массив 678</para>
  <para>10.8.2. Пример: абстрактный тип данных — строка 679</para>
  <para>10.8.3. Пример: абстрактный тип данных — очередь 679</para>
  <para>10.9. Классы-контейнеры и итераторы 680</para>
  <para>10.10. Классы-посредники 681</para>
  <para>10.11. Заключение 684</para>
  <para>Глава 11. Перегрузка операций; объекты Array и String 691</para>
  <para>11.1. Введение 692</para>
  <para>11.2. Основы перегрузки операций 693</para>
  <para>11.3. Ограничения на перегрузку операций 695</para>
  <para>11.4. Функции-операции как элементы класса и как глобальные</para>
  <para>функции 697</para>
  <para>11.5. Перегрузка операций передачи в поток и извлечения</para>
  <para>из потока 698</para>
  <para>11.6. Перегрузка одноместных операций 702</para>
  <para>11.7. Перегрузка двухместных операций 703</para>
  <para>11.8. Пример: класс Array 703</para>
  <para>11.9. Преобразование типов 716</para>
  <para>11.10. Пример: класс String 717</para>
  <para>11.11. Перегрузка++и-- 730</para>
  <para>11.12. Пример: класс Date 732</para>
  <para>11.13. Класс string стандартной библиотеки 737</para>
  <para>11.14. explicit-конструкторы 741</para>
  <para>11.15. Заключение 744</para>
  <para>Глава 12. Объектно-ориентированное программирование:</para>
  <para>наследование 759</para>
  <para>12.1. Введение 760</para>
  <para>12.2. Базовые и производные классы 762</para>
  <para>12.3. Защищенные элементы 765</para>
  <para>12.4. Отношения между базовыми и производными классами .... 766</para>
  <para>12.4.1. Создание и тестирование класса CommissionEmployee 767</para>
  <para>12.4.2. Создание класса BasePlusCommissionEmployee</para>
  <para>без наследования 772</para>
  <para>12.4.3. Создание иерархии наследования CommissionEmployee —</para>
  <para>BasePlusCommissionEmployee 777</para>
  <para>12.4.4. Иерархия наследования CommissionEmployee —</para>
  <para>BasePlusCommissionEmployee с защищенными данными .... 783</para>
  <para>12.4.5. Иерархия наследования CommissionEmployee —</para>
  <para>BasePlusCommissionEmployee с закрытыми данными 790</para>
  <para>12.5. Конструкторы и деструкторы в производных классах 798</para>
  <para>12.6. Открытое, защищенное и закрытое наследование 80610</para>
  <para>Как программировать на C++</para>
  <para>12.7. Наследование в конструировании программного обеспечения . . 807</para>
  <para>12.8. Заключение 809</para>
  <para>Глава 13. Объектно-ориентированное программирование:</para>
  <para>полиморфизм 815</para>
  <para>13.1. Введение 817</para>
  <para>13.2. Примеры полиморфизма 818</para>
  <para>13.3. Отношения между объектами в иерархии наследования .... 820</para>
  <para>13.3.1. Вызов функций базового класса из объектов производного</para>
  <para>класса 821</para>
  <para>13 3.2. Установка указателей производного класса на объекты базового</para>
  <para>класса 828</para>
  <para>13.3.3. Вызов элемент-функций производного класса через указатели</para>
  <para>базового класса 829</para>
  <para>13.3.4. Виртуальные функции 831</para>
  <para>13.3.5. Сводка допустимых присваиваний объектов указателям базового</para>
  <para>и производного классов 837</para>
  <para>13.4. Поля типа и операторы switch 838</para>
  <para>13.5. Абстрактные классы и чисто виртуальные функции 839</para>
  <para>13.6. Пример. Система начисления заработной платы, использующая</para>
  <para>полиморфизм 842</para>
  <para>13.6.1. Создание абстрактного базового класса Employee 843</para>
  <para>13.6.2. Создание конкретного производного класса SalariedEmployee . 847</para>
  <para>13.6.3. Создание конкретного производного класса HourlyEmployee . . 849</para>
  <para>13.6.4. Создание конкретного производного класса</para>
  <para>CommissionEmployee 851</para>
  <para>13.6.5. Создание косвенного конкретного производного класса</para>
  <para>BasePlusCommissionEmployee 853</para>
  <para>13.6.6. Демонстрация полиморфной обработки 855</para>
  <para>13.7. (Дополнительный раздел.) Техническая сторона полиморфизма,</para>
  <para>виртуальных функций и динамического связывания 860</para>
  <para>13.8. Пример. Система начисления заработной платы, использующая</para>
  <para>полиморфизм и информацию о типе времени выполнения с</para>
  <para>нисходящими приведениями типа, dynamic_cast, typeid</para>
  <para>и type_info 864</para>
  <para>13.9. Виртуальные деструкторы 868</para>
  <para>13.10. Конструирование программного обеспечения. Введение</para>
  <para>наследования в систему ATM (необязательный раздел) .... 869</para>
  <para>13.11. Заключение 878</para>
  <para>Глава 14. Шаблоны 885</para>
  <para>14.1. Введение 886</para>
  <para>14.2. Шаблоны функций 887</para>
  <para>14.3. Перегрузка шаблонов функции 891</para>
  <para>14.4. Шаблоны классов 891</para>
  <para>14.5. Нетиповые параметры и типы по умолчанию для шаблонов</para>
  <para>класса 898</para>
  <para>14.6. Замечания о шаблонах и наследовании 899</para>
  <para>14.7. Замечания о шаблонах и друзьях 900Содержание 11</para>
  <para>14.8. Замечания о шаблонах и статических элементах 901</para>
  <para>14.9. Заключение 901</para>
  <para>Глава 15. Потоковый ввод/вывод 907</para>
  <para>15.1. Введение 909</para>
  <para>15.2. Потоки 909</para>
  <para>15.2.1. Классические и стандартные потоки 910</para>
  <para>15.2.2. Заголовочные файлы библиотеки iostream 911</para>
  <para>15.2.3. Классы и объекты потокового ввода/вывода 911</para>
  <para>15.3. Потоковый вывод 914</para>
  <para>15.3.1. Вывод переменных типа char * 914</para>
  <para>15.3.2. Вывод символов с помощью элемент-функции put 915</para>
  <para>15.4. Потоковый ввод 915</para>
  <para>15.4.1. Элемент-функции get и getline 916</para>
  <para>15.4.2. Элемент-функции peek, putback и ignore класса istream. . . . 919</para>
  <para>15.4.3. Безопасный по типу ввод/вывод 920</para>
  <para>15.5. Бесформатный ввод/вывод с помощью read, gcount и write. . . 920</para>
  <para>15.6. Введение в манипуляторы потоков 921</para>
  <para>15.6.1. Основание целых чисел: dec, oct, hex и setbase 921</para>
  <para>15.6.2. Точность чисел с плавающей точкой (precision, setprecision). . 922</para>
  <para>15.6.3. Ширина поля (setw, width) 924</para>
  <para>15.6.4. Определяемые пользователем манипуляторы выходного</para>
  <para>потока 925</para>
  <para>15.7. Состояния формата потока и потоковые манипуляторы . . . . 927</para>
  <para>15.7.1. Конечные нули и десятичные точки (showpoint) 928</para>
  <para>15.7.2. Выравнивание (left, right, internal) 929</para>
  <para>15.7.3. Заполнение (fill, setfill) 930</para>
  <para>15.7.4. Основание целых чисел (dec, oct, hex, showbase) 932</para>
  <para>15.7.5. Числа с плавающей точкой: научная и фиксированная нотация</para>
  <para>(scientific, fixed) 933</para>
  <para>15.7.6. Управление верхним/нижним регистрами (uppercase) 934</para>
  <para>15.7.7. Спецификация булева формата (boolalpha) 935</para>
  <para>15.7.8. Установка и сброс состояний формата с помощью</para>
  <para>элемент-функции flags 936</para>
  <para>15.8. Состояния ошибки потоков 937</para>
  <para>15.9. Привязка потока вывода к потоку ввода 939</para>
  <para>15.10. Заключение 940</para>
  <para>Глава 16. Управление исключениями 951</para>
  <para>16.1. Введение 952</para>
  <para>16.2. Обзор управления исключениями 953</para>
  <para>16.3. Пример: обработка попытки деления на ноль 954</para>
  <para>16.4. Когда следует применять управление исключениями 961</para>
  <para>16.5. Перебрасывание исключений 962</para>
  <para>16.6. Спецификации исключений 964</para>
  <para>16.7. Обработка непредусмотренных исключений 965</para>
  <para>16.8. Разматывание стека 966</para>
  <para>16.9. Конструкторы, деструкторы и управление исключениями ... 967</para>
  <para>16.10. Исключения и наследование 96812 Как программировать на C++</para>
  <para>16.11. Обработка отказов операции new 969</para>
  <para>16.12. Класс auto_ptr и динамическое выделение памяти 973</para>
  <para>16.17. Иерархия исключений стандартной библиотеки 976</para>
  <para>16.14. Другие методы обработки ошибок 978</para>
  <para>16.15. Заключение 979</para>
  <para>Глава 17. Обработка файлов 987</para>
  <para>17.1. Введение 988</para>
  <para>17.2. Иерархия данных 988</para>
  <para>17.3. Файлы и потоки 991</para>
  <para>17.4. Создание последовательного файла 992</para>
  <para>17.5. Чтение данных из последовательного файла 996</para>
  <para>17.6. Обновление последовательных файлов 1003</para>
  <para>17.7. Файлы произвольного доступа 1003</para>
  <para>17.8. Создание файла произвольного доступа 1004</para>
  <para>17.9. Произвольная запись данных в файл произвольного доступа . 1010</para>
  <para>17.10. Последовательное чтение из файла произвольного доступа . . 1012</para>
  <para>17.11. Пример. Программа обработки транзакций 1015</para>
  <para>17.12. Ввод/вывод объектов 1021</para>
  <para>17.13. Заключение 1022</para>
  <para>Глава 18. Класс string и обработка строковых потоков 1033</para>
  <para>18.1. Введение 1034</para>
  <para>18.2. Присваивание и конкатенация строк 1036</para>
  <para>18.3. Сравнение строк 1038</para>
  <para>18.4. Подстроки 1041</para>
  <para>18.5. Обмен строк 1041</para>
  <para>18.6. Характеристики строки 1042</para>
  <para>18.7. Поиск в строке подстрок и символов 1045</para>
  <para>18.8. Замена символов в строке 1047</para>
  <para>18.9. Вставка символов в строку 1049</para>
  <para>18.10. Преобразование в строки-указатели С типа char * 1050</para>
  <para>18.11. Итераторы 1051</para>
  <para>18.12. Обработка строковых потоков 1053</para>
  <para>18.13. Заключение 1056</para>
  <para>Глава 19. Поиск и сортировка 1063</para>
  <para>19.1. Введение 1064</para>
  <para>19.2. Алгоритмы поиска 1065</para>
  <para>19.2.1. Эффективность линейного поиска 1065</para>
  <para>19.2.2. Двоичный поиск 1067</para>
  <para>19.3. Алгоритмы сортировки 1073</para>
  <para>19.3.1. Эффективность сортировки выборкой 1073</para>
  <para>19.3.2. Эффективность сортировки вставкой 1073</para>
  <para>19.3.3. Сортировка слиянием (рекурсивная реализация) 1074</para>
  <para>19.4. Заключение 1081Содержание 13</para>
  <para>Глава 20. Структуры данных 1089</para>
  <para>20.1. Введение 1090</para>
  <para>20.2. Автореферентные классы 1091</para>
  <para>20.3. Динамическое распределение памяти и структуры данных . . 1092</para>
  <para>20.4. Связанные списки 1093</para>
  <para>20.5. Стеки 1109</para>
  <para>20.6. Очереди 1113</para>
  <para>20.7. Деревья 1117</para>
  <para>20.8. Заключение 1127</para>
  <para>Глава 21. Биты, символы, строки С и структуры 1153</para>
  <para>21.1. Введение 1154</para>
  <para>21.2. Определение структур 1155</para>
  <para>21.3. Инициализация структур 1157</para>
  <para>21.4. Использование структур с функциями 1158</para>
  <para>21.5. typedef 1158</para>
  <para>21.6. Пример. Высокоэффективное моделирование тасования</para>
  <para>и сдачи карт 1159</para>
  <para>21.7. Поразрядные операции 1162</para>
  <para>21.8. Битовые поля 1171</para>
  <para>21.9. Библиотека обработки символов 1175</para>
  <para>21.10. Функции преобразования строк-указателей 1181</para>
  <para>21.11. Функции поиска из библиотеки обработки строк-указателей . 1186</para>
  <para>21.12. Функции управления памятью из библиотеки обработки</para>
  <para>строк-указателей 1191</para>
  <para>21.13. Заключение 1195</para>
  <para>Глава 22. Библиотека стандартных шаблонов (STL) 1209</para>
  <para>22.1. Введение в Библиотеку стандартных шаблонов (STL) 1211</para>
  <para>22.1.1. Введение в контейнеры 1213</para>
  <para>22.1.2. Введение в итераторы 1218</para>
  <para>22.1.3. Введение в алгоритмы 1224</para>
  <para>22.2. Контейнеры последовательностей 1226</para>
  <para>22.2.1. Контейнер последовательности vector 1227</para>
  <para>22.2.2. Контейнер последовательности list 1236</para>
  <para>22.2.3. Контейнер последовательности deque 1240</para>
  <para>22.3. Ассоциативные контейнеры 1242</para>
  <para>22.3.1. Ассоциативный контейнер multiset 1242</para>
  <para>22.3.2. Ассоциативный контейнер set 1245</para>
  <para>22.3.3. Ассоциативный контейнер multimap 1247</para>
  <para>22.3.4. Ассоциативный контейнер тар 1249</para>
  <para>22.4. Адаптеры контейнеров 1250</para>
  <para>22.4.1. Адаптер stack 1251</para>
  <para>22.4.2. Адаптер queue 1253</para>
  <para>22.4.3. Адаптер priority_queue 1254</para>
  <para>22.5. Алгоритмы 1256</para>
  <para>22.5.1. fill, filln, generate и generate_n 1257</para>
  <para>22.5.2. equal, mismatch и lexicographical_compare 125814 Как программировать на C++</para>
  <para>22.5.3. remove, remove_if, remove_copy и removecopyif 1261</para>
  <para>22.5.4. replace, replace_if, replace_copy и replace_copy_if 1264</para>
  <para>22.5.5. Математические алгоритмы 1266</para>
  <para>22.5.6. Элементарные алгоритмы поиска и сортировки 1269</para>
  <para>22.5.7. swap, iter_swap и swap_ranges 1272</para>
  <para>22.5.8. copy_backward, merge, unique и reverse 1273</para>
  <para>22.5.9. inplace_merge, unique_copy и reverse_copy 1276</para>
  <para>22.5.10. Операции над множествами 1277</para>
  <para>22.5.11. lower_bound, upper_bound и equal_range 1281</para>
  <para>22.5.12. Кучевая сортировка 1283</para>
  <para>22.5.13. min и max 1286</para>
  <para>22.5.14. Алгоритмы STL, не представленные в этой главе 1287</para>
  <para>22.6. Класс bitset 1289</para>
  <para>22.7. Функциональные объекты 1292</para>
  <para>22.8. Заключение 1296</para>
  <para>22.9. Ресурсы по STL в Internet и Web 1296</para>
  <para>Глава 23. Специальные вопросы 1307</para>
  <para>23.1. Введение 1308</para>
  <para>23.2. Операция const_cast 1308</para>
  <para>23.3. Пространства имен 1310</para>
  <para>23.4. Ключевые слова для операций 1315</para>
  <para>23.5. Элементы класса со спецификатором mutable 1317</para>
  <para>23.6. Указатели на элементы класса (.* и -&gt;*) 1319</para>
  <para>23.7. Сложное наследование 1321</para>
  <para>23.8. Сложное наследование и виртуальные базовые классы .... 1326</para>
  <para>23.9. Заключение 1331</para>
  <para>23.10. Последние замечания 1331</para>
</article>
