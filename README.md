Предисловие . . 17

Глава 1. Введение в компьютеры, Internet и World Wide Web 53
1.1. Введение 54
1.2. Что такое компьютер? 56
1.3. Организация компьютера 57
1.4. Первые операционные системы 58
1.5. Модели обработки данных: персональная, распределенная
и клиент/сервер 59
1.6. Internet и World Wide Web 59
1.7. Машинные языки, языки ассемблера и языки высокого уровня. . 60
1.8. История С и C++ 61
1.9. Стандартная библиотека C++ 62
1.10. История языка Java 64
1.11. FORTRAN, COBOL, Pascal и Ada 64
1.12. BASIC, Visual Basic, Visual C++, C# и .NET 65
1.13. Ключевая тенденция в программировании: объектная
технология 66
1.14. Типичная среда разработки C++ 67
1.15. Замечания о C++ и этой книге 70
1.16. Тестовый запуск приложения на C++ 72
1.17. Конструирование программного обеспечения. Введение
в объектную технологию и UML (обязательный раздел) 78
1.18. Заключение 85
1.19. Ресурсы Web 85
Глава 2. Введение в программирование на C++ 95
2.1. Введение 96
2.2. Первая программа на C++: печать строки текста 96
2.3. Модификация нашей первой программы 101
2.4. Другая программа на C++: сложение целых чисел 102
2.5. Организация памяти 107
2.6. Арифметика 109
2.7. Принятие решений: операции равенства и отношений 1136
Как программировать на C++
2.8. Конструирование программного обеспечения.
Исследование требований к ATM (необязательный раздел). . . .118
2.9. Заключение 129
Глава 3. Введение в классы и объекты 139
3.1. Введение 140
3.2. Классы, объекты, элемент-функции и элементы данных . . . . 141
3.3. Обзор примеров главы 142
3.4. Определение класса с элемент-функцией 143
3.5. Определение элемент-функции с параметром 147
3.6. Элементы данных, set-функции и gef-функции 151
3.7. Инициализация объектов при помощи конструкторов 159
3.8. Размещение класса в отдельном файле 163
3.9. Отделение интерфейса от реализации 168
3.10. Подтверждение данных посредством set-функций 174
3.11. Конструирование программного обеспечения. Идентификация
классов в спецификации требований к ATM (необязательный
раздел) 180
3.12. Заключение 188
Глава 4. Управляющие операторы: часть I 197
4.1. Введение 198
4.2. Алгоритмы 199
4.3. Псевдокод 199
4.4. Управляющие структуры 201
4.5. Оператор выбора if 205
4.6. Оператор выбора if...else 207
4.7. Оператор повторения while 212
4.8. Формулирование алгоритмов: повторение, управляемое
счетчиком 214
4.9. Формулирование алгоритмов: повторение, управляемое
контрольным значением 221
4.10. Формулирование алгоритмов: вложенные управляющие
операторы 233
4.11. Операции присваивания 238
4.12. Операции инкремента и декремента 239
4.13. Конструирование программного обеспечения. Идентификация
классовых атрибутов в системе ATM (необязательный раздел) . 242
4.14. Заключение 247
Глава 5. Управляющие операторы: часть II 265
5.1. Введение 266
5.2. Основы повторения, управляемого счетчиком 267
5.3. Оператор повторения for 269
5.4. Примеры операторов for 274
5.5. Оператор повторения do...while 279
5.6. Оператор множественного выбора switch 281
5.7. Операторы break и continue 292Содержание 7
5.8. Логические операции 294
5.9. Случайная подмена операции равенства (==) присваиванием (=). 299
5.10. Структурное программирование: резюме 301
5.11. Конструирование программного обеспечения. Идентификация
состояний объектов и деятельности в системе ATM
(необязательный раздел) 307
5.12. Заключение 313
Глава 6. Функции и введение в рекурсию 325
6.1. Введение 326
6.2. Компоненты программ на C++ 327
6.3. Функции математической библиотеки 329
6.4. Определения функций с несколькими параметрами 331
6.5. Прототипы функций и принудительное приведение аргументов . 336
6.6. Заголовочные файлы стандартной библиотеки C++ 339
6.7. Пример: генерация случайных чисел 341
6.8. Пример: азартная игра с использованием перечисления (enum) . 347
6.9. Классы памяти 351
6.10. Правила для области действия 355
6.11. Стек вызовов и активационные записи 358
6.12. Функции с пустым списком параметров 363
6.13. Встроенные функции 365
6.14. Ссылки и ссылочные параметры 366
6.15. Аргументы по умолчанию 372
6.16. Унарная операция разрешения области действия 374
6.17. Перегрузка функций 375
6.18. Шаблоны функций 379
6.19. Рекурсия 381
6.20. Пример рекурсии: числа Фибоначчи 385
6.21. Рекурсия в сравнении с итерацией 388
6.22. Конструирование программного обеспечения. Идентификация
операций классов в системе ATM (необязательный раздел) . . . 392
6.23. Заключение 400
Глава 7. Массивы и векторы 423
7.1. Введение 424
7.2. Массивы 425
7.3. Объявление массивов 427
7.4. Примеры с массивами 428
7.5. Передача массивов функциям 446
7.6. Пример: класс GradeBook с массивом для хранения оценок . . . 450
7.7. Линейный поиск в массивах 457
7.8. Сортировка массивов вставкой 459
7.9. Многомерные массивы 461
7.10. Пример: класс GradeBook с двумерным массивом 465
7.11. Введение в шаблон класса vector стандартной библиотеки C++ . 4728 Как программировать на C++
7.12. Конструирование программного обеспечения. Кооперация
объектов в системе ATM (необязательный раздел) 477
7.13. Заключение 486
Глава 8. Указатели и строки-указатели 505
8.1. Введение 506
8.2. Объявление и инициализация переменных-указателей 507
8.3. Операции указателей 508
8.4. Передача аргументов по ссылке с помощью указателей 512
8.5. Квалификатор const в применении к указателям 516
8.6. Сортировка выборкой с передачей по ссылке 524
8.7. Операции sizeof 527
8.8. Выражения с указателями и арифметика указателей 530
8.9. Взаимосвязь указателей и массивов 534
8.10. Массивы указателей 538
8.11. Пример: моделирование тасования и сдачи карт 540
8.12. Указатели на функцию 546
8.13. Введение в обработку строк-указателей 551
8.13.1. Элементарные сведения о символах и строках 551
8.13.2. Функции обработки строк из библиотеки <cstring> 554
8.14. Заключение 562
Глава 9. Классы: часть I 591
9.1. Введение 592
9.2. Пример: класс Time 593
9.3. Область действия класса и доступ к элементам класса 601
9.4. Отделение интерфейса от реализации 603
9.5. Функции доступа и сервисные функции 604
9.6. Пример: класс Time. Конструкторы с аргументами
по умолчанию 607
9.7. Деструкторы 613
9.8. Когда вызываются конструкторы и деструкторы 613
9.9. Пример: класс Time. Скрытая ошибка — возвращение ссылки
на закрытый элемент данных 617
9.10. Поэлементное присваивание по умолчанию 620
9.11. Утилизируемость программного обеспечения 622
9.12. Конструирование программного обеспечения. Начало
программирования классов системы ATM
(необязательный раздел) 623
9.13. Заключение 631
Глава 10. Классы: часть II 639
10.1. Введение 640
10.2. Константные объекты и константные элемент-функции .... 641
10.3. Композиция: объекты в качестве элементов класса 651
10.4. Дружественные функции и дружественные классы 658
10.5.-Указатель this 662Содержание 9
10.6. Динамическое управление памятью с помощью операций
new и delete 668
10.7. Статические элементы класса 670
10.8. Абстракция данных и сокрытие информации 677
10.8.1. Пример: абстрактный тип данных — массив 678
10.8.2. Пример: абстрактный тип данных — строка 679
10.8.3. Пример: абстрактный тип данных — очередь 679
10.9. Классы-контейнеры и итераторы 680
10.10. Классы-посредники 681
10.11. Заключение 684
Глава 11. Перегрузка операций; объекты Array и String 691
11.1. Введение 692
11.2. Основы перегрузки операций 693
11.3. Ограничения на перегрузку операций 695
11.4. Функции-операции как элементы класса и как глобальные
функции 697
11.5. Перегрузка операций передачи в поток и извлечения
из потока 698
11.6. Перегрузка одноместных операций 702
11.7. Перегрузка двухместных операций 703
11.8. Пример: класс Array 703
11.9. Преобразование типов 716
11.10. Пример: класс String 717
11.11. Перегрузка++и-- 730
11.12. Пример: класс Date 732
11.13. Класс string стандартной библиотеки 737
11.14. explicit-конструкторы 741
11.15. Заключение 744
Глава 12. Объектно-ориентированное программирование:
наследование 759
12.1. Введение 760
12.2. Базовые и производные классы 762
12.3. Защищенные элементы 765
12.4. Отношения между базовыми и производными классами .... 766
12.4.1. Создание и тестирование класса CommissionEmployee 767
12.4.2. Создание класса BasePlusCommissionEmployee
без наследования 772
12.4.3. Создание иерархии наследования CommissionEmployee —
BasePlusCommissionEmployee 777
12.4.4. Иерархия наследования CommissionEmployee —
BasePlusCommissionEmployee с защищенными данными .... 783
12.4.5. Иерархия наследования CommissionEmployee —
BasePlusCommissionEmployee с закрытыми данными 790
12.5. Конструкторы и деструкторы в производных классах 798
12.6. Открытое, защищенное и закрытое наследование 80610
Как программировать на C++
12.7. Наследование в конструировании программного обеспечения . . 807
12.8. Заключение 809
Глава 13. Объектно-ориентированное программирование:
полиморфизм 815
13.1. Введение 817
13.2. Примеры полиморфизма 818
13.3. Отношения между объектами в иерархии наследования .... 820
13.3.1. Вызов функций базового класса из объектов производного
класса 821
13 3.2. Установка указателей производного класса на объекты базового
класса 828
13.3.3. Вызов элемент-функций производного класса через указатели
базового класса 829
13.3.4. Виртуальные функции 831
13.3.5. Сводка допустимых присваиваний объектов указателям базового
и производного классов 837
13.4. Поля типа и операторы switch 838
13.5. Абстрактные классы и чисто виртуальные функции 839
13.6. Пример. Система начисления заработной платы, использующая
полиморфизм 842
13.6.1. Создание абстрактного базового класса Employee 843
13.6.2. Создание конкретного производного класса SalariedEmployee . 847
13.6.3. Создание конкретного производного класса HourlyEmployee . . 849
13.6.4. Создание конкретного производного класса
CommissionEmployee 851
13.6.5. Создание косвенного конкретного производного класса
BasePlusCommissionEmployee 853
13.6.6. Демонстрация полиморфной обработки 855
13.7. (Дополнительный раздел.) Техническая сторона полиморфизма,
виртуальных функций и динамического связывания 860
13.8. Пример. Система начисления заработной платы, использующая
полиморфизм и информацию о типе времени выполнения с
нисходящими приведениями типа, dynamic_cast, typeid
и type_info 864
13.9. Виртуальные деструкторы 868
13.10. Конструирование программного обеспечения. Введение
наследования в систему ATM (необязательный раздел) .... 869
13.11. Заключение 878
Глава 14. Шаблоны 885
14.1. Введение 886
14.2. Шаблоны функций 887
14.3. Перегрузка шаблонов функции 891
14.4. Шаблоны классов 891
14.5. Нетиповые параметры и типы по умолчанию для шаблонов
класса 898
14.6. Замечания о шаблонах и наследовании 899
14.7. Замечания о шаблонах и друзьях 900Содержание 11
14.8. Замечания о шаблонах и статических элементах 901
14.9. Заключение 901
Глава 15. Потоковый ввод/вывод 907
15.1. Введение 909
15.2. Потоки 909
15.2.1. Классические и стандартные потоки 910
15.2.2. Заголовочные файлы библиотеки iostream 911
15.2.3. Классы и объекты потокового ввода/вывода 911
15.3. Потоковый вывод 914
15.3.1. Вывод переменных типа char * 914
15.3.2. Вывод символов с помощью элемент-функции put 915
15.4. Потоковый ввод 915
15.4.1. Элемент-функции get и getline 916
15.4.2. Элемент-функции peek, putback и ignore класса istream. . . . 919
15.4.3. Безопасный по типу ввод/вывод 920
15.5. Бесформатный ввод/вывод с помощью read, gcount и write. . . 920
15.6. Введение в манипуляторы потоков 921
15.6.1. Основание целых чисел: dec, oct, hex и setbase 921
15.6.2. Точность чисел с плавающей точкой (precision, setprecision). . 922
15.6.3. Ширина поля (setw, width) 924
15.6.4. Определяемые пользователем манипуляторы выходного
потока 925
15.7. Состояния формата потока и потоковые манипуляторы . . . . 927
15.7.1. Конечные нули и десятичные точки (showpoint) 928
15.7.2. Выравнивание (left, right, internal) 929
15.7.3. Заполнение (fill, setfill) 930
15.7.4. Основание целых чисел (dec, oct, hex, showbase) 932
15.7.5. Числа с плавающей точкой: научная и фиксированная нотация
(scientific, fixed) 933
15.7.6. Управление верхним/нижним регистрами (uppercase) 934
15.7.7. Спецификация булева формата (boolalpha) 935
15.7.8. Установка и сброс состояний формата с помощью
элемент-функции flags 936
15.8. Состояния ошибки потоков 937
15.9. Привязка потока вывода к потоку ввода 939
15.10. Заключение 940
Глава 16. Управление исключениями 951
16.1. Введение 952
16.2. Обзор управления исключениями 953
16.3. Пример: обработка попытки деления на ноль 954
16.4. Когда следует применять управление исключениями 961
16.5. Перебрасывание исключений 962
16.6. Спецификации исключений 964
16.7. Обработка непредусмотренных исключений 965
16.8. Разматывание стека 966
16.9. Конструкторы, деструкторы и управление исключениями ... 967
16.10. Исключения и наследование 96812 Как программировать на C++
16.11. Обработка отказов операции new 969
16.12. Класс auto_ptr и динамическое выделение памяти 973
16.17. Иерархия исключений стандартной библиотеки 976
16.14. Другие методы обработки ошибок 978
16.15. Заключение 979
Глава 17. Обработка файлов 987
17.1. Введение 988
17.2. Иерархия данных 988
17.3. Файлы и потоки 991
17.4. Создание последовательного файла 992
17.5. Чтение данных из последовательного файла 996
17.6. Обновление последовательных файлов 1003
17.7. Файлы произвольного доступа 1003
17.8. Создание файла произвольного доступа 1004
17.9. Произвольная запись данных в файл произвольного доступа . 1010
17.10. Последовательное чтение из файла произвольного доступа . . 1012
17.11. Пример. Программа обработки транзакций 1015
17.12. Ввод/вывод объектов 1021
17.13. Заключение 1022
Глава 18. Класс string и обработка строковых потоков 1033
18.1. Введение 1034
18.2. Присваивание и конкатенация строк 1036
18.3. Сравнение строк 1038
18.4. Подстроки 1041
18.5. Обмен строк 1041
18.6. Характеристики строки 1042
18.7. Поиск в строке подстрок и символов 1045
18.8. Замена символов в строке 1047
18.9. Вставка символов в строку 1049
18.10. Преобразование в строки-указатели С типа char * 1050
18.11. Итераторы 1051
18.12. Обработка строковых потоков 1053
18.13. Заключение 1056
Глава 19. Поиск и сортировка 1063
19.1. Введение 1064
19.2. Алгоритмы поиска 1065
19.2.1. Эффективность линейного поиска 1065
19.2.2. Двоичный поиск 1067
19.3. Алгоритмы сортировки 1073
19.3.1. Эффективность сортировки выборкой 1073
19.3.2. Эффективность сортировки вставкой 1073
19.3.3. Сортировка слиянием (рекурсивная реализация) 1074
19.4. Заключение 1081Содержание 13
Глава 20. Структуры данных 1089
20.1. Введение 1090
20.2. Автореферентные классы 1091
20.3. Динамическое распределение памяти и структуры данных . . 1092
20.4. Связанные списки 1093
20.5. Стеки 1109
20.6. Очереди 1113
20.7. Деревья 1117
20.8. Заключение 1127
Глава 21. Биты, символы, строки С и структуры 1153
21.1. Введение 1154
21.2. Определение структур 1155
21.3. Инициализация структур 1157
21.4. Использование структур с функциями 1158
21.5. typedef 1158
21.6. Пример. Высокоэффективное моделирование тасования
и сдачи карт 1159
21.7. Поразрядные операции 1162
21.8. Битовые поля 1171
21.9. Библиотека обработки символов 1175
21.10. Функции преобразования строк-указателей 1181
21.11. Функции поиска из библиотеки обработки строк-указателей . 1186
21.12. Функции управления памятью из библиотеки обработки
строк-указателей 1191
21.13. Заключение 1195
Глава 22. Библиотека стандартных шаблонов (STL) 1209
22.1. Введение в Библиотеку стандартных шаблонов (STL) 1211
22.1.1. Введение в контейнеры 1213
22.1.2. Введение в итераторы 1218
22.1.3. Введение в алгоритмы 1224
22.2. Контейнеры последовательностей 1226
22.2.1. Контейнер последовательности vector 1227
22.2.2. Контейнер последовательности list 1236
22.2.3. Контейнер последовательности deque 1240
22.3. Ассоциативные контейнеры 1242
22.3.1. Ассоциативный контейнер multiset 1242
22.3.2. Ассоциативный контейнер set 1245
22.3.3. Ассоциативный контейнер multimap 1247
22.3.4. Ассоциативный контейнер тар 1249
22.4. Адаптеры контейнеров 1250
22.4.1. Адаптер stack 1251
22.4.2. Адаптер queue 1253
22.4.3. Адаптер priority_queue 1254
22.5. Алгоритмы 1256
22.5.1. fill, filln, generate и generate_n 1257
22.5.2. equal, mismatch и lexicographical_compare 125814 Как программировать на C++
22.5.3. remove, remove_if, remove_copy и removecopyif 1261
22.5.4. replace, replace_if, replace_copy и replace_copy_if 1264
22.5.5. Математические алгоритмы 1266
22.5.6. Элементарные алгоритмы поиска и сортировки 1269
22.5.7. swap, iter_swap и swap_ranges 1272
22.5.8. copy_backward, merge, unique и reverse 1273
22.5.9. inplace_merge, unique_copy и reverse_copy 1276
22.5.10. Операции над множествами 1277
22.5.11. lower_bound, upper_bound и equal_range 1281
22.5.12. Кучевая сортировка 1283
22.5.13. min и max 1286
22.5.14. Алгоритмы STL, не представленные в этой главе 1287
22.6. Класс bitset 1289
22.7. Функциональные объекты 1292
22.8. Заключение 1296
22.9. Ресурсы по STL в Internet и Web 1296
Глава 23. Специальные вопросы 1307
23.1. Введение 1308
23.2. Операция const_cast 1308
23.3. Пространства имен 1310
23.4. Ключевые слова для операций 1315
23.5. Элементы класса со спецификатором mutable 1317
23.6. Указатели на элементы класса (.* и ->*) 1319
23.7. Сложное наследование 1321
23.8. Сложное наследование и виртуальные базовые классы .... 1326
23.9. Заключение 1331
23.10. Последние замечания 1331
Дейтел Х., Дейтел П. "Как программировать на С++", 5 издание, 2008~
Предисловие . . 17
Глава 1. Введение в компьютеры, Internet и World Wide Web 53
1.1. Введение 54
1.2. Что такое компьютер? 56
1.3. Организация компьютера 57
1.4. Первые операционные системы 58
1.5. Модели обработки данных: персональная, распределенная
и клиент/сервер 59
1.6. Internet и World Wide Web 59
1.7. Машинные языки, языки ассемблера и языки высокого уровня. . 60
1.8. История С и C++ 61
1.9. Стандартная библиотека C++ 62
1.10. История языка Java 64
1.11. FORTRAN, COBOL, Pascal и Ada 64
1.12. BASIC, Visual Basic, Visual C++, C# и .NET 65
1.13. Ключевая тенденция в программировании: объектная
технология 66
1.14. Типичная среда разработки C++ 67
1.15. Замечания о C++ и этой книге 70
1.16. Тестовый запуск приложения на C++ 72
1.17. Конструирование программного обеспечения. Введение
в объектную технологию и UML (обязательный раздел) 78
1.18. Заключение 85
1.19. Ресурсы Web 85
Глава 2. Введение в программирование на C++ 95
2.1. Введение 96
2.2. Первая программа на C++: печать строки текста 96
2.3. Модификация нашей первой программы 101
2.4. Другая программа на C++: сложение целых чисел 102
2.5. Организация памяти 107
2.6. Арифметика 109
2.7. Принятие решений: операции равенства и отношений 1136
Как программировать на C++
2.8. Конструирование программного обеспечения.
Исследование требований к ATM (необязательный раздел). . . .118
2.9. Заключение 129
Глава 3. Введение в классы и объекты 139
3.1. Введение 140
3.2. Классы, объекты, элемент-функции и элементы данных . . . . 141
3.3. Обзор примеров главы 142
3.4. Определение класса с элемент-функцией 143
3.5. Определение элемент-функции с параметром 147
3.6. Элементы данных, set-функции и gef-функции 151
3.7. Инициализация объектов при помощи конструкторов 159
3.8. Размещение класса в отдельном файле 163
3.9. Отделение интерфейса от реализации 168
3.10. Подтверждение данных посредством set-функций 174
3.11. Конструирование программного обеспечения. Идентификация
классов в спецификации требований к ATM (необязательный
раздел) 180
3.12. Заключение 188
Глава 4. Управляющие операторы: часть I 197
4.1. Введение 198
4.2. Алгоритмы 199
4.3. Псевдокод 199
4.4. Управляющие структуры 201
4.5. Оператор выбора if 205
4.6. Оператор выбора if...else 207
4.7. Оператор повторения while 212
4.8. Формулирование алгоритмов: повторение, управляемое
счетчиком 214
4.9. Формулирование алгоритмов: повторение, управляемое
контрольным значением 221
4.10. Формулирование алгоритмов: вложенные управляющие
операторы 233
4.11. Операции присваивания 238
4.12. Операции инкремента и декремента 239
4.13. Конструирование программного обеспечения. Идентификация
классовых атрибутов в системе ATM (необязательный раздел) . 242
4.14. Заключение 247
Глава 5. Управляющие операторы: часть II 265
5.1. Введение 266
5.2. Основы повторения, управляемого счетчиком 267
5.3. Оператор повторения for 269
5.4. Примеры операторов for 274
5.5. Оператор повторения do...while 279
5.6. Оператор множественного выбора switch 281
5.7. Операторы break и continue 292Содержание 7
5.8. Логические операции 294
5.9. Случайная подмена операции равенства (==) присваиванием (=). 299
5.10. Структурное программирование: резюме 301
5.11. Конструирование программного обеспечения. Идентификация
состояний объектов и деятельности в системе ATM
(необязательный раздел) 307
5.12. Заключение 313
Глава 6. Функции и введение в рекурсию 325
6.1. Введение 326
6.2. Компоненты программ на C++ 327
6.3. Функции математической библиотеки 329
6.4. Определения функций с несколькими параметрами 331
6.5. Прототипы функций и принудительное приведение аргументов . 336
6.6. Заголовочные файлы стандартной библиотеки C++ 339
6.7. Пример: генерация случайных чисел 341
6.8. Пример: азартная игра с использованием перечисления (enum) . 347
6.9. Классы памяти 351
6.10. Правила для области действия 355
6.11. Стек вызовов и активационные записи 358
6.12. Функции с пустым списком параметров 363
6.13. Встроенные функции 365
6.14. Ссылки и ссылочные параметры 366
6.15. Аргументы по умолчанию 372
6.16. Унарная операция разрешения области действия 374
6.17. Перегрузка функций 375
6.18. Шаблоны функций 379
6.19. Рекурсия 381
6.20. Пример рекурсии: числа Фибоначчи 385
6.21. Рекурсия в сравнении с итерацией 388
6.22. Конструирование программного обеспечения. Идентификация
операций классов в системе ATM (необязательный раздел) . . . 392
6.23. Заключение 400
Глава 7. Массивы и векторы 423
7.1. Введение 424
7.2. Массивы 425
7.3. Объявление массивов 427
7.4. Примеры с массивами 428
7.5. Передача массивов функциям 446
7.6. Пример: класс GradeBook с массивом для хранения оценок . . . 450
7.7. Линейный поиск в массивах 457
7.8. Сортировка массивов вставкой 459
7.9. Многомерные массивы 461
7.10. Пример: класс GradeBook с двумерным массивом 465
7.11. Введение в шаблон класса vector стандартной библиотеки C++ . 4728 Как программировать на C++
7.12. Конструирование программного обеспечения. Кооперация
объектов в системе ATM (необязательный раздел) 477
7.13. Заключение 486
Глава 8. Указатели и строки-указатели 505
8.1. Введение 506
8.2. Объявление и инициализация переменных-указателей 507
8.3. Операции указателей 508
8.4. Передача аргументов по ссылке с помощью указателей 512
8.5. Квалификатор const в применении к указателям 516
8.6. Сортировка выборкой с передачей по ссылке 524
8.7. Операции sizeof 527
8.8. Выражения с указателями и арифметика указателей 530
8.9. Взаимосвязь указателей и массивов 534
8.10. Массивы указателей 538
8.11. Пример: моделирование тасования и сдачи карт 540
8.12. Указатели на функцию 546
8.13. Введение в обработку строк-указателей 551
8.13.1. Элементарные сведения о символах и строках 551
8.13.2. Функции обработки строк из библиотеки <cstring> 554
8.14. Заключение 562
Глава 9. Классы: часть I 591
9.1. Введение 592
9.2. Пример: класс Time 593
9.3. Область действия класса и доступ к элементам класса 601
9.4. Отделение интерфейса от реализации 603
9.5. Функции доступа и сервисные функции 604
9.6. Пример: класс Time. Конструкторы с аргументами
по умолчанию 607
9.7. Деструкторы 613
9.8. Когда вызываются конструкторы и деструкторы 613
9.9. Пример: класс Time. Скрытая ошибка — возвращение ссылки
на закрытый элемент данных 617
9.10. Поэлементное присваивание по умолчанию 620
9.11. Утилизируемость программного обеспечения 622
9.12. Конструирование программного обеспечения. Начало
программирования классов системы ATM
(необязательный раздел) 623
9.13. Заключение 631
Глава 10. Классы: часть II 639
10.1. Введение 640
10.2. Константные объекты и константные элемент-функции .... 641
10.3. Композиция: объекты в качестве элементов класса 651
10.4. Дружественные функции и дружественные классы 658
10.5.-Указатель this 662Содержание 9
10.6. Динамическое управление памятью с помощью операций
new и delete 668
10.7. Статические элементы класса 670
10.8. Абстракция данных и сокрытие информации 677
10.8.1. Пример: абстрактный тип данных — массив 678
10.8.2. Пример: абстрактный тип данных — строка 679
10.8.3. Пример: абстрактный тип данных — очередь 679
10.9. Классы-контейнеры и итераторы 680
10.10. Классы-посредники 681
10.11. Заключение 684
Глава 11. Перегрузка операций; объекты Array и String 691
11.1. Введение 692
11.2. Основы перегрузки операций 693
11.3. Ограничения на перегрузку операций 695
11.4. Функции-операции как элементы класса и как глобальные
функции 697
11.5. Перегрузка операций передачи в поток и извлечения
из потока 698
11.6. Перегрузка одноместных операций 702
11.7. Перегрузка двухместных операций 703
11.8. Пример: класс Array 703
11.9. Преобразование типов 716
11.10. Пример: класс String 717
11.11. Перегрузка++и-- 730
11.12. Пример: класс Date 732
11.13. Класс string стандартной библиотеки 737
11.14. explicit-конструкторы 741
11.15. Заключение 744
Глава 12. Объектно-ориентированное программирование:
наследование 759
12.1. Введение 760
12.2. Базовые и производные классы 762
12.3. Защищенные элементы 765
12.4. Отношения между базовыми и производными классами .... 766
12.4.1. Создание и тестирование класса CommissionEmployee 767
12.4.2. Создание класса BasePlusCommissionEmployee
без наследования 772
12.4.3. Создание иерархии наследования CommissionEmployee —
BasePlusCommissionEmployee 777
12.4.4. Иерархия наследования CommissionEmployee —
BasePlusCommissionEmployee с защищенными данными .... 783
12.4.5. Иерархия наследования CommissionEmployee —
BasePlusCommissionEmployee с закрытыми данными 790
12.5. Конструкторы и деструкторы в производных классах 798
12.6. Открытое, защищенное и закрытое наследование 80610
Как программировать на C++
12.7. Наследование в конструировании программного обеспечения . . 807
12.8. Заключение 809
Глава 13. Объектно-ориентированное программирование:
полиморфизм 815
13.1. Введение 817
13.2. Примеры полиморфизма 818
13.3. Отношения между объектами в иерархии наследования .... 820
13.3.1. Вызов функций базового класса из объектов производного
класса 821
13 3.2. Установка указателей производного класса на объекты базового
класса 828
13.3.3. Вызов элемент-функций производного класса через указатели
базового класса 829
13.3.4. Виртуальные функции 831
13.3.5. Сводка допустимых присваиваний объектов указателям базового
и производного классов 837
13.4. Поля типа и операторы switch 838
13.5. Абстрактные классы и чисто виртуальные функции 839
13.6. Пример. Система начисления заработной платы, использующая
полиморфизм 842
13.6.1. Создание абстрактного базового класса Employee 843
13.6.2. Создание конкретного производного класса SalariedEmployee . 847
13.6.3. Создание конкретного производного класса HourlyEmployee . . 849
13.6.4. Создание конкретного производного класса
CommissionEmployee 851
13.6.5. Создание косвенного конкретного производного класса
BasePlusCommissionEmployee 853
13.6.6. Демонстрация полиморфной обработки 855
13.7. (Дополнительный раздел.) Техническая сторона полиморфизма,
виртуальных функций и динамического связывания 860
13.8. Пример. Система начисления заработной платы, использующая
полиморфизм и информацию о типе времени выполнения с
нисходящими приведениями типа, dynamic_cast, typeid
и type_info 864
13.9. Виртуальные деструкторы 868
13.10. Конструирование программного обеспечения. Введение
наследования в систему ATM (необязательный раздел) .... 869
13.11. Заключение 878
Глава 14. Шаблоны 885
14.1. Введение 886
14.2. Шаблоны функций 887
14.3. Перегрузка шаблонов функции 891
14.4. Шаблоны классов 891
14.5. Нетиповые параметры и типы по умолчанию для шаблонов
класса 898
14.6. Замечания о шаблонах и наследовании 899
14.7. Замечания о шаблонах и друзьях 900Содержание 11
14.8. Замечания о шаблонах и статических элементах 901
14.9. Заключение 901
Глава 15. Потоковый ввод/вывод 907
15.1. Введение 909
15.2. Потоки 909
15.2.1. Классические и стандартные потоки 910
15.2.2. Заголовочные файлы библиотеки iostream 911
15.2.3. Классы и объекты потокового ввода/вывода 911
15.3. Потоковый вывод 914
15.3.1. Вывод переменных типа char * 914
15.3.2. Вывод символов с помощью элемент-функции put 915
15.4. Потоковый ввод 915
15.4.1. Элемент-функции get и getline 916
15.4.2. Элемент-функции peek, putback и ignore класса istream. . . . 919
15.4.3. Безопасный по типу ввод/вывод 920
15.5. Бесформатный ввод/вывод с помощью read, gcount и write. . . 920
15.6. Введение в манипуляторы потоков 921
15.6.1. Основание целых чисел: dec, oct, hex и setbase 921
15.6.2. Точность чисел с плавающей точкой (precision, setprecision). . 922
15.6.3. Ширина поля (setw, width) 924
15.6.4. Определяемые пользователем манипуляторы выходного
потока 925
15.7. Состояния формата потока и потоковые манипуляторы . . . . 927
15.7.1. Конечные нули и десятичные точки (showpoint) 928
15.7.2. Выравнивание (left, right, internal) 929
15.7.3. Заполнение (fill, setfill) 930
15.7.4. Основание целых чисел (dec, oct, hex, showbase) 932
15.7.5. Числа с плавающей точкой: научная и фиксированная нотация
(scientific, fixed) 933
15.7.6. Управление верхним/нижним регистрами (uppercase) 934
15.7.7. Спецификация булева формата (boolalpha) 935
15.7.8. Установка и сброс состояний формата с помощью
элемент-функции flags 936
15.8. Состояния ошибки потоков 937
15.9. Привязка потока вывода к потоку ввода 939
15.10. Заключение 940
Глава 16. Управление исключениями 951
16.1. Введение 952
16.2. Обзор управления исключениями 953
16.3. Пример: обработка попытки деления на ноль 954
16.4. Когда следует применять управление исключениями 961
16.5. Перебрасывание исключений 962
16.6. Спецификации исключений 964
16.7. Обработка непредусмотренных исключений 965
16.8. Разматывание стека 966
16.9. Конструкторы, деструкторы и управление исключениями ... 967
16.10. Исключения и наследование 96812 Как программировать на C++
16.11. Обработка отказов операции new 969
16.12. Класс auto_ptr и динамическое выделение памяти 973
16.17. Иерархия исключений стандартной библиотеки 976
16.14. Другие методы обработки ошибок 978
16.15. Заключение 979
Глава 17. Обработка файлов 987
17.1. Введение 988
17.2. Иерархия данных 988
17.3. Файлы и потоки 991
17.4. Создание последовательного файла 992
17.5. Чтение данных из последовательного файла 996
17.6. Обновление последовательных файлов 1003
17.7. Файлы произвольного доступа 1003
17.8. Создание файла произвольного доступа 1004
17.9. Произвольная запись данных в файл произвольного доступа . 1010
17.10. Последовательное чтение из файла произвольного доступа . . 1012
17.11. Пример. Программа обработки транзакций 1015
17.12. Ввод/вывод объектов 1021
17.13. Заключение 1022
Глава 18. Класс string и обработка строковых потоков 1033
18.1. Введение 1034
18.2. Присваивание и конкатенация строк 1036
18.3. Сравнение строк 1038
18.4. Подстроки 1041
18.5. Обмен строк 1041
18.6. Характеристики строки 1042
18.7. Поиск в строке подстрок и символов 1045
18.8. Замена символов в строке 1047
18.9. Вставка символов в строку 1049
18.10. Преобразование в строки-указатели С типа char * 1050
18.11. Итераторы 1051
18.12. Обработка строковых потоков 1053
18.13. Заключение 1056
Глава 19. Поиск и сортировка 1063
19.1. Введение 1064
19.2. Алгоритмы поиска 1065
19.2.1. Эффективность линейного поиска 1065
19.2.2. Двоичный поиск 1067
19.3. Алгоритмы сортировки 1073
19.3.1. Эффективность сортировки выборкой 1073
19.3.2. Эффективность сортировки вставкой 1073
19.3.3. Сортировка слиянием (рекурсивная реализация) 1074
19.4. Заключение 1081Содержание 13
Глава 20. Структуры данных 1089
20.1. Введение 1090
20.2. Автореферентные классы 1091
20.3. Динамическое распределение памяти и структуры данных . . 1092
20.4. Связанные списки 1093
20.5. Стеки 1109
20.6. Очереди 1113
20.7. Деревья 1117
20.8. Заключение 1127
Глава 21. Биты, символы, строки С и структуры 1153
21.1. Введение 1154
21.2. Определение структур 1155
21.3. Инициализация структур 1157
21.4. Использование структур с функциями 1158
21.5. typedef 1158
21.6. Пример. Высокоэффективное моделирование тасования
и сдачи карт 1159
21.7. Поразрядные операции 1162
21.8. Битовые поля 1171
21.9. Библиотека обработки символов 1175
21.10. Функции преобразования строк-указателей 1181
21.11. Функции поиска из библиотеки обработки строк-указателей . 1186
21.12. Функции управления памятью из библиотеки обработки
строк-указателей 1191
21.13. Заключение 1195
Глава 22. Библиотека стандартных шаблонов (STL) 1209
22.1. Введение в Библиотеку стандартных шаблонов (STL) 1211
22.1.1. Введение в контейнеры 1213
22.1.2. Введение в итераторы 1218
22.1.3. Введение в алгоритмы 1224
22.2. Контейнеры последовательностей 1226
22.2.1. Контейнер последовательности vector 1227
22.2.2. Контейнер последовательности list 1236
22.2.3. Контейнер последовательности deque 1240
22.3. Ассоциативные контейнеры 1242
22.3.1. Ассоциативный контейнер multiset 1242
22.3.2. Ассоциативный контейнер set 1245
22.3.3. Ассоциативный контейнер multimap 1247
22.3.4. Ассоциативный контейнер тар 1249
22.4. Адаптеры контейнеров 1250
22.4.1. Адаптер stack 1251
22.4.2. Адаптер queue 1253
22.4.3. Адаптер priority_queue 1254
22.5. Алгоритмы 1256
22.5.1. fill, filln, generate и generate_n 1257
22.5.2. equal, mismatch и lexicographical_compare 125814 Как программировать на C++
22.5.3. remove, remove_if, remove_copy и removecopyif 1261
22.5.4. replace, replace_if, replace_copy и replace_copy_if 1264
22.5.5. Математические алгоритмы 1266
22.5.6. Элементарные алгоритмы поиска и сортировки 1269
22.5.7. swap, iter_swap и swap_ranges 1272
22.5.8. copy_backward, merge, unique и reverse 1273
22.5.9. inplace_merge, unique_copy и reverse_copy 1276
22.5.10. Операции над множествами 1277
22.5.11. lower_bound, upper_bound и equal_range 1281
22.5.12. Кучевая сортировка 1283
22.5.13. min и max 1286
22.5.14. Алгоритмы STL, не представленные в этой главе 1287
22.6. Класс bitset 1289
22.7. Функциональные объекты 1292
22.8. Заключение 1296
22.9. Ресурсы по STL в Internet и Web 1296
Глава 23. Специальные вопросы 1307
23.1. Введение 1308
23.2. Операция const_cast 1308
23.3. Пространства имен 1310
23.4. Ключевые слова для операций 1315
23.5. Элементы класса со спецификатором mutable 1317
23.6. Указатели на элементы класса (.* и ->*) 1319
23.7. Сложное наследование 1321
23.8. Сложное наследование и виртуальные базовые классы .... 1326
23.9. Заключение 1331
23.10. Последние замечания 1331
